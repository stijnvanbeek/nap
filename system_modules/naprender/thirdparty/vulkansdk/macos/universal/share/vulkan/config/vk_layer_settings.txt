# The settings in this file can be used to configure the behavior of layers in this repository.
# This file doesn't display the dependencies on the various settings
#
# This file is generated by generate_settings.py

# VK_LAYER_KHRONOS_validation
               
# Command Buffer State
# =====================
# Check that all Vulkan objects used by a command buffer have not been destroyed. These checks can be CPU intensive for some applications.
khronos_validation.check_command_buffer = true

# Image Layout
# =====================
# Check that the layout of each image subresource is correct whenever it is used by a command buffer. These checks are very CPU intensive for some applications.
khronos_validation.check_image_layout = true

# Object in Use
# =====================
# Check that Vulkan objects are not in use by a command buffer when they are destroyed.
khronos_validation.check_object_in_use = true

# Query
# =====================
# Checks for commands that use VkQueryPool objects.
khronos_validation.check_query = true

# Shader
# =====================
# This will validate the contents of the SPIR-V which can be CPU intensive during application start up. This does internal checks as well as calling spirv-val.
khronos_validation.check_shaders = true

# Caching
# =====================
# Creates an internal instance of VK_EXT_validation_cache and upon vkDestroyInstance, will cache the shader validation so sequential usage of the validation layers will be skipped.
khronos_validation.check_shaders_caching = true

# Debug Action
# =====================
# Specifies what action is to be taken when a layer reports information
khronos_validation.debug_action = VK_DBG_LAYER_ACTION_LOG_MSG

# Deprecation
# =====================
# Give warnings when using deprecated parts of the API.
khronos_validation.deprecation = false

# Max Duplicated Messages
# =====================
# Maximum number of times any single validation message should be reported.
khronos_validation.duplicate_message_limit = 10

# Limit Duplicated Messages
# =====================
# Enable limiting of duplicate messages.
khronos_validation.enable_message_limit = true

# Fine Grained Locking
# =====================
# Enable fine grained locking for Core Validation, which should improve performance in multithreaded applications. This setting allows the optimization to be disabled for debugging.
khronos_validation.fine_grained_locking = true

# Out of bounds buffer device addresses
# =====================
# Check for invalid access using buffer device address
khronos_validation.gpuav_buffer_address_oob = true

# Buffer copies
# =====================
# Validate copies involving a VkBuffer. Right now only validates copy buffer to image.
khronos_validation.gpuav_buffer_copies = true

# Buffer content validation
# =====================
# Validate buffers containing parameters used in indirect Vulkan commands, or used in copy commands
khronos_validation.gpuav_buffers_validation = true

# Descriptors indexing
# =====================
# Enable descriptors and buffer out of bounds validation when using descriptor indexing
khronos_validation.gpuav_descriptor_checks = true

# GPU Assisted Validation
# =====================
# Enable validation that cannot be done the CPU and needs hooks into the GPU execution
khronos_validation.gpuav_enable = false

# Force on robustness features
# =====================
# This will enable all possible robustness features for the app at device creation time. This can be used to quickly detect if with robustness, your issue disappears. GPU-AV will also skip validating things already covered by robustness, so turning on should reduce GPU-AV performance overhead.
khronos_validation.gpuav_force_on_robustness = false

# Index buffers
# =====================
# Validate that indexed draws do not fetch indices outside of the bounds of the index buffer.
khronos_validation.gpuav_index_buffers = true

# Indirect dispatches parameters
# =====================
# Validate buffers containing dispatch parameters used in indirect dispatch commands
khronos_validation.gpuav_indirect_dispatches_buffers = true

# Indirect draws parameters
# =====================
# Validate buffers containing draw parameters used in indirect draw commands. Includes vkCmdDrawMeshTasks* calls as well
khronos_validation.gpuav_indirect_draws_buffers = true

# Indirect trace rays parameters
# =====================
# Validate buffers containing ray tracing parameters used in indirect ray tracing commands
khronos_validation.gpuav_indirect_trace_rays_buffers = true

# Post process descriptor indexing
# =====================
# Track which descriptor indexes were used in shader to run normal validation afterwards
khronos_validation.gpuav_post_process_descriptor_indexing = true

# Safe Mode
# =====================
# Will have GPU-AV try and prevent crashes, but will be much slower to validate. If using Safe Mode, consider using selective shader instrumentation, to only instrument the shaders/pipelines causing issues.
khronos_validation.gpuav_safe_mode = false

# Enable instrumenting shaders selectively
# =====================
# Select which shaders to instrument by passing a VkValidationFeaturesEXT struct with GPU-AV enabled in the VkShaderModuleCreateInfo pNext or using a regex matching a shader/pipeline debug name. Because this only validates the selected shaders, it will allow GPU-AV to run much faster.
khronos_validation.gpuav_select_instrumented_shaders = false

# Shader instrumentation
# =====================
# Instrument shaders to validate descriptors, descriptor indexing, buffer device addresses and ray queries. Warning: will considerably slow down shader executions.
khronos_validation.gpuav_shader_instrumentation = true

# Shader/pipeline name regexes
# =====================
# Any shader or pipeline library debug name (set with vkSetDebugUtilsObjectNameEXT) fully matching any listed regular expression will be instrumented when creating pipelines with those shaders or libraries. Regex grammar: Modified ECMAScript. No support for shader objects yet. Warning: instrumentation being performed at final pipeline creation time, if shaders modules have already been destroyed at this step (possible when using pipeline libraries), they won't be found by this regex selection system. In this case, consider naming pipeline libraries instead.
khronos_validation.gpuav_shaders_to_instrument = 

# RayQuery SPIR-V instructions
# =====================
# Enable shader instrumentation on OpRayQueryInitializeKHR
khronos_validation.gpuav_validate_ray_query = true

# Out of bounds vertex attribute fetching
# =====================
# Validate that no vertex attribute fetching is out of bonds
khronos_validation.gpuav_vertex_attribute_fetch_oob = true

# Log Filename
# =====================
# Specifies the output filename
khronos_validation.log_filename = stdout

# Display Application Name
# =====================
# Useful when running multiple instances to know which instance the message is from.
khronos_validation.message_format_display_application_name = false

# JSON
# =====================
# Display Validation as JSON (VkDebugUtilsMessengerCallbackDataEXT::pMessage will contain JSON)
khronos_validation.message_format_json = false

# Mute Message VUIDs
# =====================
# List of VUIDs and VUID identifiers which are to be IGNORED by the validation layer
khronos_validation.message_id_filter = 

# Object Lifetime
# =====================
# Object tracking checks. This may not always be necessary late in a development cycle.
khronos_validation.object_lifetime = true

# Printf buffer size
# =====================
# Set the size in bytes of the buffer per draw/dispatch/traceRays to hold the messages
khronos_validation.printf_buffer_size = 1024

# Debug Printf
# =====================
# Enable DebugPrintf and will print anything use NonSemantic.DebugPrintf in their SPIR-V
khronos_validation.printf_enable = false

# Debug Printf only preset
# =====================
# A single, quick setting to turn on only DebugPrintf and turn off everything else
khronos_validation.printf_only_preset = false

# Redirect Printf messages to stdout
# =====================
# Enable redirection of Debug Printf messages from the debug callback to stdout
khronos_validation.printf_to_stdout = true

# Printf verbose
# =====================
# Will print out handles, instruction location, position in command buffer, and more
khronos_validation.printf_verbose = false

# Message Severity
# =====================
# Comma-delineated list of options specifying the types of messages to be reported
khronos_validation.report_flags = error

# Stateless Parameter
# =====================
# Stateless parameter checks. This may not always be necessary late in a development cycle.
khronos_validation.stateless_param = true

# Extra properties
# =====================
# Append a section of key-value properties to the error message. Useful for filtering errors.
khronos_validation.syncval_message_extra_properties = false

# Shader accesses heuristic
# =====================
# Take into account memory accesses performed by the shader based on SPIR-V static analysis. Warning: can produce false-positives, can ignore certain types of accesses.
khronos_validation.syncval_shader_accesses_heuristic = false

# Submit time validation
# =====================
# Enable synchronization validation on the boundary between submitted command buffers. This also validates accesses from presentation operations. This option can incur a significant performance cost.
khronos_validation.syncval_submit_time_validation = true

# Thread Safety
# =====================
# Thread checks. In order to not degrade performance, it might be best to run your program with thread-checking disabled most of the time, enabling it occasionally for a quick sanity check or when debugging difficult application behaviors.
khronos_validation.thread_safety = true

# Handle Wrapping
# =====================
# Handle wrapping checks. Disable this feature if you are experiencing crashes when creating new extensions or developing new Vulkan objects/structures.
khronos_validation.unique_handles = true

# Best Practices
# =====================
# Outputs warnings related to common misuse of the API, but which are not explicitly prohibited by the specification.
khronos_validation.validate_best_practices = false

# AMD-specific best practices
# =====================
# Outputs warnings for spec-conforming but non-ideal code on AMD GPUs.
khronos_validation.validate_best_practices_amd = false

# ARM-specific best practices
# =====================
# Outputs warnings for spec-conforming but non-ideal code on ARM GPUs.
khronos_validation.validate_best_practices_arm = false

# IMG-specific best practices
# =====================
# Outputs warnings for spec-conforming but non-ideal code on Imagination GPUs.
khronos_validation.validate_best_practices_img = false

# NVIDIA-specific best practices
# =====================
# Outputs warnings for spec-conforming but non-ideal code on NVIDIA GPUs.
khronos_validation.validate_best_practices_nvidia = false

# Core
# =====================
# The main, heavy-duty validation checks. This may be valuable early in the development cycle to reduce validation output while correcting parameter/object usage errors.
khronos_validation.validate_core = true

# Synchronization
# =====================
# Check for resource access conflicts caused by missing or incorrectly used synchronization operations.
khronos_validation.validate_sync = false

# The settings in this file can be used to configure the behavior of
# layers in this repository.
#
# Note that this file is not regulary updated, so not all possible layer
# settings may be listed, and some layer settings may even be obsolete.

# VK_LAYER_LUNARG_api_dump

# Output Range
# =====================
# <LayerIdentifier>.output_range
# Comma separated list of frames to output or a range of frames with a start,
# count, and optional interval separated by a dash. A count of 0 will output
# every frame after the start of the range. Example: "5-8-2" will output frame
# 5, continue until frame 13, dumping every other frame. Example: "3,8-2" will
# output frames 3, 8, and 9.
lunarg_api_dump.output_range = 0-0

# Output Format
# =====================
# <LayerIdentifier>.output_format
# Specifies the format used for output; can be HTML, JSON, or  Text (default --
# outputs plain text)
lunarg_api_dump.output_format = text

# Output to File
# =====================
# <LayerIdentifier>.file
# Setting this to true indicates that output should be written to file instead
# of stdout
lunarg_api_dump.file = false

# Log Filename
# =====================
# <LayerIdentifier>.log_filename
# Specifies the file to dump to when output files are enabled
#lunarg_api_dump.log_filename = stdout

# Log Flush After Write
# =====================
# <LayerIdentifier>.flush
# Setting this to true causes IO to be flushed after each API call that is
# written
lunarg_api_dump.flush = true

# Name Size
# =====================
# <LayerIdentifier>.name_size
# The number of characters the name of a variable should consume, assuming more
# are not required
lunarg_api_dump.name_size = 32

# Show Types
# =====================
# <LayerIdentifier>.show_types
# Dump types in addition to values
lunarg_api_dump.show_types = true

# Type Size
# =====================
# <LayerIdentifier>.type_size
# The number of characters the name of a type should consume, assuming more are
# not required
lunarg_api_dump.type_size = 0

# Show Timestamp
# =====================
# <LayerIdentifier>.show_timestamp
# Show the timestamp of function calls since start in microseconds
lunarg_api_dump.show_timestamp = false

# Show Shader
# =====================
# <LayerIdentifier>.show_shader
# Dump the shader binary code in pCode
lunarg_api_dump.show_shader = false

# Show Parameter Details
# =====================
# <LayerIdentifier>.detailed
# Dump parameter details in addition to API calls
lunarg_api_dump.detailed = true

# Hide Addresses
# =====================
# <LayerIdentifier>.no_addr
# Dump "address" in place of hex addresses
lunarg_api_dump.no_addr = false

# Use Spaces
# =====================
# <LayerIdentifier>.use_spaces
# Setting this to true causes all tab characters to be replaced with spaces
lunarg_api_dump.use_spaces = true

# Indent Size
# =====================
# <LayerIdentifier>.indent_size
# Specifies the number of spaces that a tab is equal to
lunarg_api_dump.indent_size = 4

# Show Thread and Frame
# =====================
# <LayerIdentifier>.show_thread_and_frame
# Show the thread and frame of each function called
lunarg_api_dump.show_thread_and_frame = true


# VK_LAYER_LUNARG_screenshot

# Frames
# =====================
# <LayerIdentifier>.frames
# Specifies list of frames to output as screenshots. It is specified as a
# comma-separated list of frames or a range of frames with a start, count, and
# optional interval separated by a dash. Setting the variable to "all" will
# output every frame. Example: "5-8-2" will output frame 5, continue until frame
# 13, dumping every other frame. Example: "3,8-2" will output frames 3, 8, and
# 9. If it is not set or it set to an empty string, no screenshots are created.
lunarg_screenshot.frames = 

# Directory
# =====================
# <LayerIdentifier>.dir
# Specifies the directory in which to create the screenshot files. If it is not
# set or is set to an empty string, the files will be created in the current
# working directory.
lunarg_screenshot.dir = 

# Format
# =====================
# <LayerIdentifier>.format
# Specify a color space for the output. If it is not set, set to null, or set to
# USE_SWAPCHAIN_COLORSPACE the format will be set to use the same color space as
# the swapchain object.
lunarg_screenshot.format = USE_SWAPCHAIN_COLORSPACE

# The settings in this file can be used to configure the behavior of
# layers in this repository.
#
# Note that this file is not regulary updated, so not all possible layer
# settings may be listed, and some layer settings may even be obsolete.

# VK_LAYER_KHRONOS_synchronization2

# Force Enable
# =====================
# <LayerIdentifier>.force_enable
# Force the layer to be active even if the underlying driver also implements the
# synchonization2 extension.
khronos_synchronization2.force_enable = false

# VK_LAYER_KHRONOS_shader_object

# Force Enable
# =====================
# <LayerIdentifier>.force_enable
# Force the layer to be active even if the underlying driver also implements the
# shader object extension.
khronos_shader_object.force_enable = false

# VK_LAYER_KHRONOS_memory_decompression

# Force Enable
# =====================
# <LayerIdentifier>.force_enable
# Force the layer to be active even if the underlying driver also implements the
# memory decompression extension.
khronos_memory_decompression.force_enable = true
# The settings in this file can be used to configure the behavior of
# layers in this repository.
#
# Note that this file is not regulary updated, so not all possible layer
# settings may be listed, and some layer settings may even be obsolete.

# VK_LAYER_LUNARG_gfxreconstruct

# Hotkey Capture Trigger
# =====================
# <LayerIdentifier>.capture_trigger
# Specify a hotkey (any one of F1-F12, TAB, CONTROL) that will be used to
# start/stop capture. Example: F3 will set the capture trigger to F3 hotkey. One
# capture file will be generated for each pair of start/stop hotkey presses.
# Default is: Empty string (hotkey capture trigger is disabled).
lunarg_gfxreconstruct.capture_trigger =

# Capture Specific Frames
# =====================
# <LayerIdentifier>.capture_frames
# Specify one or more comma-separated frame ranges to capture. Each range will
# be written to its own file. A frame range can be specified as a single value,
# to specify a single frame to capture, or as two hyphenated values, to specify
# the first and last frame to capture. Frame ranges should be specified in
# ascending order and cannot overlap. Note that frame numbering is 1-based (i.e.
# the first frame is frame 1). Example: 200,301-305 will create two capture
# files, one containing a single frame and one containing five frames. Default
# is: Empty string (all frames are captured).
lunarg_gfxreconstruct.capture_frames =

# Capture File Name
# =====================
# <LayerIdentifier>.capture_file
# Path to use when creating the capture file. Default is: gfxrecon_capture.gfxr
lunarg_gfxreconstruct.capture_file = gfxrecon_capture.gfxr

# Capture File Name with Timestamp
# =====================
# <LayerIdentifier>.capture_file_timestamp
# Add a timestamp (yyyymmddThhmmss) postfix to the capture file name.
lunarg_gfxreconstruct.capture_file_timestamp = true

# Capture File Flush After Write
# =====================
# <LayerIdentifier>.capture_file_flush
# Flush output stream after each packet is written to the capture file. Default
# is: false.
lunarg_gfxreconstruct.capture_file_flush = false

# Compression Format
# =====================
# <LayerIdentifier>.capture_compression_type
# Compression format to use with the capture file. Valid values are: LZ4, ZLIB,
# ZSTD, and NONE. Default is: LZ4
lunarg_gfxreconstruct.capture_compression_type = LZ4

# Memory Tracking Mode
# =====================
# <LayerIdentifier>.memory_tracking_mode
# Specifies the memory tracking mode to use for detecting modifications to
# mapped Vulkan memory objects. Available options are: page_guard, assisted, and
# unassisted.
lunarg_gfxreconstruct.memory_tracking_mode = page_guard

# Page Guard Copy on Map
# =====================
# <LayerIdentifier>.page_guard_copy_on_map
# When the page_guard memory tracking mode is enabled, copies the content of the
# mapped memory to the shadow memory immediately after the memory is mapped.
lunarg_gfxreconstruct.page_guard_copy_on_map = true

# Page Guard Separate Read Tracking
# =====================
# <LayerIdentifier>.page_guard_separate_read
# When the page_guard memory tracking mode is enabled, copies the content of
# pages accessed for read from mapped memory to shadow memory on each read. Can
# overwrite unprocessed shadow memory content when an application is reading
# from and writing to the same page.
lunarg_gfxreconstruct.page_guard_separate_read = true

# Page Guard External Memory
# =====================
# <LayerIdentifier>.page_guard_external_memory
# When the page_guard memory tracking mode is enabled, use the
# VK_EXT_external_memory_host extension to eliminate the need for shadow memory
# allocations. For each memory allocation from a host visible memory type, the
# capture layer will create an allocation from system memory, which it can
# monitor for write access, and provide that allocation to vkAllocateMemory as
# external memory. Only available on Windows.
lunarg_gfxreconstruct.page_guard_external_memory = false

# Page Guard Persistent Memory
# =====================
# <LayerIdentifier>.page_guard_persistent_memory
# When the page_guard memory tracking mode is enabled, this option changes the
# way that the shadow memory used to detect modifications to mapped memory is
# allocated. The default behavior is to allocate and copy the mapped memory
# range on map and free the allocation on unmap. When this option is enabled, an
# allocation with a size equal to that of the object being mapped is made once
# on the first map and is not freed until the object is destroyed. This option
# is intended to be used with applications that frequently map and unmap large
# memory ranges, to avoid frequent allocation and copy operations that can have
# a negative impact on performance. This option is ignored when
# GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY is enabled.
lunarg_gfxreconstruct.page_guard_persistent_memory = false

# Page Guard Align Buffer Sizes
# =====================
# <LayerIdentifier>.page_guard_align_buffer_sizes
# When the page_guard memory tracking mode is enabled, this option overrides the
# Vulkan API calls that report buffer memory properties to report that buffer
# sizes and alignments must be a multiple of the system page size. This option
# is intended to be used with applications that perform CPU writes and GPU
# writes/copies to different buffers that are bound to the same page of mapped
# memory, which may result in data being lost when copying pages from the
# page_guard shadow allocation to the real allocation. This data loss can result
# in visible corruption during capture. Forcing buffer sizes and alignments to a
# multiple of the system page size prevents multiple buffers from being bound to
# the same page, avoiding data loss from simultaneous CPU writes to the shadow
# allocation and GPU writes to the real allocation for different buffers bound
# to the same page. This option is only available for the Vulkan API.
lunarg_gfxreconstruct.page_guard_align_buffer_sizes = false

# Page Guard Unblock SIGSEGV
# =====================
# <LayerIdentifier>.page_guard_unblock_sigsegv
# When the page_guard memory tracking mode is enabled and in the case that
# SIGSEGV has been marked as blocked in thread's signal mask, setting this
# enviroment variable to true will forcibly re-enable the signal in the
# thread's signal mask.
lunarg_gfxreconstruct.page_guard_unblock_sigsegv = false

# Level
# =====================
# <LayerIdentifier>.log_level
# Specify the minimum severity level of messages to log. Options are: debug,
# info, warning, error, and fatal. The specified level and all higher levels
# will be enabled for logging. For example, choosing the warning level will also
# enable the error and fatal levels.
lunarg_gfxreconstruct.log_level = info

# Log Name and Line Number
# =====================
# <LayerIdentifier>.log_detailed
# Include name and line number from the file responsible.
lunarg_gfxreconstruct.log_detailed = false

# Log Name and Line Number
# =====================
# <LayerIdentifier>.log_allow_indents
# Apply additional indentation formatting to log messages.
lunarg_gfxreconstruct.log_allow_indents = false

# Log Output to Console / stdout
# =====================
# <LayerIdentifier>.log_output_to_console
# Log messages will be written to stdout.
lunarg_gfxreconstruct.log_output_to_console = true

# Trigger Debug Break on Error
# =====================
# <LayerIdentifier>.log_break_on_error
# Trigger a debug break when logging an error.
lunarg_gfxreconstruct.log_break_on_error = false

# Log Output to Debug Console
# =====================
# <LayerIdentifier>.log_output_to_os_debug_string
# Windows only option. Log messages will be written to the Debug Console with
# OutputDebugStringA
lunarg_gfxreconstruct.log_output_to_os_debug_string = false

# Log File
# =====================
# <LayerIdentifier>.log_file
# When set, log messages will be written to a file at the specified path.
# Default is: Empty string (file logging disabled).
lunarg_gfxreconstruct.log_file =

# Log File Flush After Write
# =====================
# <LayerIdentifier>.log_file_flush_after_write
# Flush the log file to disk after each write when true.
lunarg_gfxreconstruct.log_file_flush_after_write = false

# Log File Keep Open
# =====================
# <LayerIdentifier>.log_file_keep_open
# Keep the log file open between log messages when true, or close and reopen the
# log file for each message when false.
lunarg_gfxreconstruct.log_file_keep_open = true

# Log File Overwrite
# =====================
# <LayerIdentifier>.log_file_create_new
# Specifies that log file initialization should overwrite an existing file when
# true, or append to an existing file when false.
lunarg_gfxreconstruct.log_file_create_new = true
